# Fastfile for LiteByte iOS Build Automation
# This fastlane configuration handles uploading builds to TestFlight

default_platform(:ios)

# Disable analytics and junit to avoid encoding issues
opt_out_usage
ENV['FASTLANE_SKIP_JUNIT'] = '1'

platform :ios do
  desc "Upload iOS build to TestFlight"
  lane :tf_upload do |options|
    begin
      # Get the IPA path from options or fallback search
      ipa_path = options[:ipa_path] || Dir.glob("../.build/last/*.ipa").first || Dir.glob("*.ipa").first
      
      if ipa_path.nil? || !File.exist?(ipa_path)
        UI.user_error!("‚ùå No IPA file found at: #{ipa_path || 'any standard path'}")
      end
      
      UI.success("üì¶ Found IPA: #{ipa_path}")
      
      # Get API key from environment
      api_key_base64 = ENV['APPLE_AUTH_LITEBYTE']
      issuer_id = ENV['APPLE_ISSUER_ID']
      key_id = "5NK3TP4SCM"
      
      if api_key_base64.nil? || issuer_id.nil?
        UI.user_error!("‚ùå APPLE_AUTH_LITEBYTE or APPLE_ISSUER_ID not set in environment")
      end
      
      # Decode API key
      require 'base64'
      require 'json'
      require 'tempfile'
      
      # Decode from base64
      key_bytes = Base64.decode64(api_key_base64)
      
      # Try to detect if it's already UTF-8 text or needs conversion
      if key_bytes.start_with?("-----BEGIN")
        # It's already text
        key_pem_text = key_bytes
      elsif key_bytes[0..10].bytes.any? { |b| b > 127 || b == 0 }
        # Looks like binary - this is wrong, the .p8 should be text
        UI.user_error!("‚ùå APPLE_AUTH_LITEBYTE appears to contain binary data. It should be base64-encoded PEM text starting with '-----BEGIN PRIVATE KEY-----'")
      else
        key_pem_text = key_bytes
      end
      
      # Force UTF-8 encoding and clean any BOMs
      key_pem_text = key_pem_text.force_encoding('UTF-8').encode('UTF-8', invalid: :replace, undef: :replace)
      key_pem_text = key_pem_text.sub(/^\xEF\xBB\xBF/, '') # Remove UTF-8 BOM if present
      
      UI.message("üîê Using App Store Connect API key authentication")
      UI.message("Key starts with: #{key_pem_text[0..30]}...")
      
      # Create JSON file with API key information (required by api_key_path)
      api_key_json = {
        "key_id" => key_id,
        "issuer_id" => issuer_id,
        "key" => key_pem_text
      }
      
      key_file = Tempfile.new(['api_key', '.json'])
      key_file.write(JSON.pretty_generate(api_key_json))
      key_file.close
      
      UI.message("üìÅ API key JSON: #{key_file.path}")
      
      # Upload to TestFlight using JSON file path
      upload_to_testflight(
        ipa: ipa_path,
        api_key_path: key_file.path,
        app_identifier: "com.liithos.litebyte",
        skip_waiting_for_build_processing: true,
        skip_submission: true,
        distribute_external: false,
        notify_external_testers: false
      )
      
      # Clean up
      key_file.unlink
      
      UI.success("‚úÖ Successfully uploaded to TestFlight!")
      UI.message("üì± Check status: https://appstoreconnect.apple.com")
      
    rescue ArgumentError => e
      # Catch UTF-8 encoding errors from JUnit generator
      if e.message.include?("invalid byte sequence in UTF-8")
        UI.important("‚ö†Ô∏è  Ignoring JUnit generator encoding error (known Fastlane bug)")
        exit(0)
      else
        raise e
      end
    end
  end
end
