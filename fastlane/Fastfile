# Fastfile for LiteByte iOS Build Automation
# This fastlane configuration handles uploading builds to TestFlight

default_platform(:ios)

# Disable analytics and junit to avoid encoding issues
opt_out_usage
ENV['FASTLANE_SKIP_JUNIT'] = '1'

platform :ios do
  desc "Upload iOS build to TestFlight"
  lane :tf_upload do |options|
    begin
      # Get the IPA path from options or fallback search
      ipa_path = options[:ipa_path] || Dir.glob("../.build/last/*.ipa").first || Dir.glob("*.ipa").first
      
      if ipa_path.nil? || !File.exist?(ipa_path)
        UI.user_error!("‚ùå No IPA file found at: #{ipa_path || 'any standard path'}")
      end
      
      UI.success("üì¶ Found IPA: #{ipa_path}")
      
      # Get API key from environment
      api_key_content = ENV['APPLE_AUTH_LITEBYTE']
      issuer_id = ENV['APPLE_ISSUER_ID']
      key_id = "5NK3TP4SCM"
      
      if api_key_content.nil? || issuer_id.nil?
        UI.user_error!("‚ùå APPLE_AUTH_LITEBYTE or APPLE_ISSUER_ID not set in environment")
      end
      
      # Decode API key
      require 'base64'
      require 'json'
      require 'tempfile'
      
      # Check if it's base64-encoded or raw PEM
      if api_key_content.start_with?("-----BEGIN")
        # Raw PEM text - use directly
        key_pem_text = api_key_content
        UI.message("üìù Using raw PEM key")
      else
        # Assume it's base64-encoded
        key_pem_text = Base64.decode64(api_key_content).force_encoding('UTF-8')
        UI.message("üìù Decoded base64 key")
      end
      
      # Remove any BOMs or weird characters
      key_pem_text = key_pem_text.encode('UTF-8', invalid: :replace, undef: :replace, replace: '')
      key_pem_text = key_pem_text.sub(/^\xEF\xBB\xBF/, '') # Remove UTF-8 BOM if present
      key_pem_text = key_pem_text.strip # Remove whitespace
      
      # Verify it looks like a PEM key
      unless key_pem_text.start_with?("-----BEGIN PRIVATE KEY-----")
        UI.user_error!("‚ùå APPLE_AUTH_LITEBYTE doesn't appear to be a valid PEM key. It should start with '-----BEGIN PRIVATE KEY-----'. Current start: '#{key_pem_text[0..50]}'")
      end
      
      UI.message("üîê Using App Store Connect API key authentication")
      UI.success("‚úì Valid PEM key detected")
      
      # Create JSON file with API key information (required by api_key_path)
      api_key_json = {
        "key_id" => key_id,
        "issuer_id" => issuer_id,
        "key" => key_pem_text
      }
      
      key_file = Tempfile.new(['api_key', '.json'])
      key_file.write(JSON.pretty_generate(api_key_json))
      key_file.close
      
      UI.message("üìÅ API key JSON: #{key_file.path}")
      
      # Upload to TestFlight using JSON file path
      upload_to_testflight(
        ipa: ipa_path,
        api_key_path: key_file.path,
        app_identifier: "com.liithos.litebyte",
        skip_waiting_for_build_processing: true,
        skip_submission: true,
        distribute_external: false,
        notify_external_testers: false
      )
      
      # Clean up
      key_file.unlink
      
      UI.success("‚úÖ Successfully uploaded to TestFlight!")
      UI.message("üì± Check status: https://appstoreconnect.apple.com")
      
    rescue ArgumentError => e
      # Catch UTF-8 encoding errors from JUnit generator
      if e.message.include?("invalid byte sequence in UTF-8")
        UI.important("‚ö†Ô∏è  Ignoring JUnit generator encoding error (known Fastlane bug)")
        exit(0)
      else
        raise e
      end
    end
  end
end
