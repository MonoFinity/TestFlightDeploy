# Fastfile for LiteByte iOS Build Automation
# This fastlane configuration handles uploading builds to TestFlight

default_platform(:ios)

# Disable analytics and junit to avoid encoding issues
opt_out_usage
ENV['FASTLANE_SKIP_JUNIT'] = '1'

platform :ios do
  desc "Upload iOS build to TestFlight"
  lane :tf_upload do |options|
    begin
      # Get the IPA path from options or fallback search
      ipa_path = options[:ipa_path] || Dir.glob("../.build/last/*.ipa").first || Dir.glob("*.ipa").first
      
      if ipa_path.nil? || !File.exist?(ipa_path)
        UI.user_error!("No IPA file found at: #{ipa_path || 'any standard path'}")
      end
      
      UI.success("Found IPA: #{ipa_path}")
      
      # Get API key details from environment
      api_key_id = ENV['APP_STORE_CONNECT_API_KEY_KEY_ID']
      api_key_issuer_id = ENV['APPLE_ISSUER_ID']
      api_key_content = ENV['APPLE_AUTH_LITEBYTE']
      
      if api_key_id.nil? || api_key_issuer_id.nil? || api_key_content.nil?
        UI.user_error!("API key environment variables not set")
      end
      
      UI.message("Using App Store Connect API Key authentication")
      UI.message("Key ID: #{api_key_id}")
      UI.message("Issuer ID: #{api_key_issuer_id}")
      UI.message("Key content length: #{api_key_content.length} characters")
      
      # Upload to TestFlight using API key
      upload_to_testflight(
        ipa: ipa_path,
        api_key: {
          key_id: api_key_id,
          issuer_id: api_key_issuer_id,
          key: api_key_content
        },
        app_identifier: "com.liithos.litebyte",
        skip_waiting_for_build_processing: true,
        skip_submission: true,
        distribute_external: false,
        notify_external_testers: false
      )
      
      UI.success("Successfully uploaded to TestFlight!")
      UI.message("Check status: https://appstoreconnect.apple.com")
      
    rescue => e
      # Capture detailed error information
      error_msg = e.message.to_s
      error_class = e.class.to_s
      
      UI.error("Error class: #{error_class}")
      UI.error("Error message: #{error_msg}")
      
      # Check for specific error types
      if error_msg.include?("Two-factor")
        UI.error("⚠️  2FA DETECTED: This account has two-factor authentication enabled")
        UI.error("Non-interactive authentication is blocked by 2FA")
        exit(1)
      elsif error_msg.include?("invalid byte sequence in UTF-8")
        UI.important("Ignoring JUnit generator encoding error (known Fastlane bug)")
        exit(0)
      else
        # Re-raise with full context
        raise e
      end
    end
  end
end
